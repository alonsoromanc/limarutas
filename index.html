<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rutas A/B/C en OSM (Leaflet)</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    #info {
      position: absolute; z-index: 1000; top: 10px; left: 10px;
      background: #fff; padding: 8px 10px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,.15);
      font: 14px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", "Noto Sans", Arial;
    }
    .legend {
      margin-top: 6px; line-height: 1.3;
    }
    .swatch { display:inline-block; width: 12px; height: 12px; border-radius: 2px; margin-right: 6px; vertical-align: -2px; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="info">
    <div><strong>Rutas</strong></div>
    <div class="legend">
      <span class="swatch" style="background:#00cfff"></span> Ruta A (celeste)<br/>
      <span class="swatch" style="background:#ff8c00"></span> Ruta B (naranja)<br/>
      <span class="swatch" style="background:#7fff00"></span> Ruta C (verde lima)
    </div>
    <div id="status" style="margin-top:6px; color:#666">Cargando datos…</div>
  </div>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script>
    // 1) Ajusta esta ruta al JSON que subiste a tu repo (GitHub Pages sirve sólo por HTTPS)
    // Si el JSON está junto a index.html, deja './metropolitano.json'
    const JSON_URL = './metropolitano.json';

    // 2) Mapa base
    const map = L.map('map', { zoomControl: true });
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; colaboradores de OpenStreetMap'
    }).addTo(map);

    // 3) Grupos por ruta con colores fijos solicitados
    const colors = { A: '#00cfff', B: '#ff8c00', C: '#7fff00' };
    const groups = {
      A: L.layerGroup().addTo(map),
      B: L.layerGroup().addTo(map),
      C: L.layerGroup().addTo(map)
    };

    // 4) Utilitario: construir LineString desde nodes
    function wayToLatLngs(way, nodeIndex) {
      const pts = [];
      for (const nid of way.nodes || []) {
        const n = nodeIndex.get(nid);
        if (n) pts.push([n.lat, n.lon]);
      }
      return pts;
    }

    // 5) Parsear Overpass JSON -> dibujar
    async function loadAndRender() {
      const status = document.getElementById('status');
      try {
        const res = await fetch(JSON_URL, { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();

        // Índice de nodos, ways y relations
        const nodeIndex = new Map();
        const wayIndex  = new Map();
        const rels = [];
        for (const el of data.elements || []) {
          if (el.type === 'node') nodeIndex.set(el.id, el);
          else if (el.type === 'way') wayIndex.set(el.id, el);
          else if (el.type === 'relation') rels.push(el);
        }

        let bounds = [];
        let any = false;

        // Intentamos asignar cada relation a A/B/C por alguna tag
        // Cambia estas reglas si tus relations tienen otras etiquetas
        function bucketFor(tags) {
          if (!tags) return null;
          // ejemplos: route=bus, ref=A/B/C, name contiene A/B/C
          if (/^a$/i.test(tags.ref) || /\bRuta\s*A\b/i.test(tags.name || '')) return 'A';
          if (/^b$/i.test(tags.ref) || /\bRuta\s*B\b/i.test(tags.name || '')) return 'B';
          if (/^c$/i.test(tags.ref) || /\bRuta\s*C\b/i.test(tags.name || '')) return 'C';
          return null;
        }

        for (const rel of rels) {
          const bucket = bucketFor(rel.tags) || 'A'; // por defecto A si no identificamos
          const layer = groups[bucket];
          const color = colors[bucket];

          // miembros tipo way
          const memberWays = (rel.members || []).filter(m => m.type === 'way');
          for (const m of memberWays) {
            const way = wayIndex.get(m.ref);
            if (!way) continue;
            const latlngs = wayToLatLngs(way, nodeIndex);
            if (latlngs.length >= 2) {
              L.polyline(latlngs, { color, weight: 4, opacity: 0.9 }).addTo(layer);
              bounds.push(...latlngs);
              any = true;
            }
          }
        }

        if (any) {
          map.fitBounds(bounds, { padding: [20,20] });
          status.textContent = 'Listo';
        } else {
          // Si no hubo relations o no se detectaron, probamos dibujar todos los ways
          let waysPlotted = 0;
          for (const way of wayIndex.values()) {
            const latlngs = wayToLatLngs(way, nodeIndex);
            if (latlngs.length >= 2) {
              L.polyline(latlngs, { color: '#666', weight: 3, opacity: 0.7 }).addTo(groups.A);
              bounds.push(...latlngs);
              waysPlotted++;
            }
          }
          if (waysPlotted) {
            map.fitBounds(bounds, { padding: [20,20] });
            status.textContent = 'Listo (dibujados ways sin relation)';
          } else {
            status.textContent = 'No se encontraron líneas que dibujar en el JSON';
          }
        }
      } catch (err) {
        console.error(err);
        document.getElementById('status').textContent = 'Error cargando datos';
      }
    }

    loadAndRender();
  </script>
</body>
</html>
